---
title: list to grid
layout: post
---

<div id="viz"></div>

<script>
$(document).ready(function(){
    var width = 100,
        height = 100,
        xcount = 40,
        ycount = 40,
        cellw = width / xcount,
        cellh = height / ycount;

    var svg = d3.select("#viz").append("svg")
        .attr("id", "svg")
        .attr("height", "100%")
        .attr("width", "100%")
        .attr("viewBox", "0 0 " + width + " " + height);

    var xscale = d3.scale.linear()
        .domain([0, xcount])
        .range([0, width]);

    var yscale = d3.scale.linear()
        .domain([0, ycount])
        .range([0, height]);

    var color = d3.scale.category10();

    var CELL_A = 1,
        CELL_B = 2,
        CELL_EMPTY = 3;

    // var COLORS = {
    //     CELL_A: '#0099cc',
    //     CELL_B: '#CCFFCC',
    //     CELL_EMPTY: '#003399',
    // };

    var COLORS = {
        CELL_A: 'lightblue',
        CELL_B: 'blue',
        CELL_EMPTY: 'white',
    };

    function update(data) {
        // join
        var cells = svg.selectAll("rect")
            .data(data);

        // update
        cells.style("fill", function(d, i) { return COLORS[d]; });

        // enter
        cells.enter().append("rect")
            .attr("x", function(d, i) { return xscale( i % xcount ); })
            .attr("y", function(d, i) { return yscale( Math.floor( i / xcount ) ); })
            .attr("width", cellw)
            .attr("height", cellh)
            .style("fill", function(d, i) { return COLORS[d]; })
            .on("click", function(d, i) {
                console.log("element " + i + " value: " + d + " with neighbors:");
                console.log(get_neighbors(data, i));
            });

        // exit
        cells.exit().remove();
    }

    /**
      * infite grid represented as a list
      */
    function get_cell(data, x, y) {
        if ( x == xcount + 1 ) { x = 0 }
        if ( y == ycount + 1 ) { y = 0 }
        if ( x == -1 ) { x = xcount; }
        if ( y == -1 ) { y = ycount; }

        return data[ y * xcount + x ];
    }

    /**
      * return the neighbors of the i-eme elememt
      * as a list
      */
    function get_neighbors(data, i) {
        var x = i % xcount,
            y = Math.floor( i / xcount );

        return [
            get_cell( data, x - 1, y + 1 ),
            get_cell( data, x,     y + 1 ),
            get_cell( data, x + 1, y + 1 ),
            get_cell( data, x - 1, y - 1 ),
            get_cell( data, x,     y - 1 ),
            get_cell( data, x + 1, y - 1 ),
            get_cell( data, x - 1, y ),
            get_cell( data, x + 1, y ) ];
    }

    function get_random_empty_position(data) {
        var random_i = Math.floor( Math.random() * ( xcount * ycount ) );
        while (true) {
            if ( data[ random_i ] == CELL_EMPTY ) {
                return random_i;
            }
            random_i++;
            if ( random_i == ( xcount * ycount ) + 1 ) {
                random_i = 0;
            }
        }
    }

    /**
      * agents are: 
      * - happy if they have at least two neighbors like themselves, 
      * - and unhappy if they have one or zero.
      * this function returns the new data list or FALSE when the
      * configuration is stable.
      */
    function step(data) {
        var start_random_i = Math.floor( Math.random() * ( xcount * ycount ) );
        
        var looping = false,
            random_i = start_random_i - 1;

        while (true) {
            random_i += 1;

            if ( looping && random_i == start_random_i ) {
                return FALSE;
            }

            var random_i_value = data[ random_i ];
            var ns = get_neighbors( data, random_i );
            var alike_neighbors_count = 0;
        
            if ( random_i_value == CELL_EMPTY ) {
                looping = true;
                continue;
            }

            for ( var i = 0; i < 8; i++ ) {
                if ( random_i_value == ns[ i ] ) {
                    alike_neighbors_count++;
                }
            }

            if ( alike_neighbors_count <= 2 ) {
                var relocated_index = get_random_empty_position(data);
                data[ relocated_index ] = random_i_value;
                data[ random_i ] = CELL_EMPTY;
            } else {
                looping = true;
                continue;
            }

            return data;
        }
    }

    data = [];

    for ( var i = 0; i < xcount * ycount; i++ ) {
        data.push( Math.floor( Math.random() * 2 ) + 1 );
    }

    for ( var i = 0; i < (xcount * ycount) / 10; i++ ) {
        var random_i = Math.floor( Math.random() * xcount * ycount );
        data[ random_i ] = CELL_EMPTY;
    }

    update( data );

    var timer = setInterval(function(){
        data = step(data);
        if (!data) {
            console.log("STABLE");
            clearInterval(timer);
        }
        update(data);
    }, 50);
});
</script>
